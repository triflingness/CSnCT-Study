# MSA
> 마이크로 서비스 아키텍쳐, MicroService Architecture

대용량 Web 서비스가 많아짐에 따라 정의된 아키텍처입니다.

- SOA에 근간을 두고 대용량 웹서비스 개발에 맞는 구조
- 정량화되고 대규모 개발팀의 조직 구도에 맞게 변형된 아키텍처

## 탄생 배경

- MA : 모노리틱 아키텍쳐, Monolithic Architecture
    - 기존의 전통적인 Web 시스템 개발 아키텍처로서 하나의 애플리케이션 내에 모든 로직이 들어가 있는 구조입니다.
    - 서비스 규모가 커지면 전체의 스케일이 커지면서 한계를 보입니다.
        - 빌드 및 배포 시간, 서버 가동시간이 증가
        - 부분의 실수가 시스템 전체에 영향을 미침
        - 따라서 MA는 규모가 작은 애플리케이션에 적합합니다.
        
        <p>
          <img src="https://github.com/triflingness/CSnCT-Study/blob/main/IT%20Common%20Sense/images/MA.png" width="300">
        </p>

## MSA 특징

<p>
  <img src="https://github.com/triflingness/CSnCT-Study/blob/main/IT%20Common%20Sense/images/MSA.png" width="700">
</p>

1. 서비스별로 독립된 서버로 타 컴포넌트와의 **의존선없이 독립적으로 배포**합니다.
      >  로드밸런서를 배치하여 서비스 간의 로드를 분산하는 것도 가능합니다.

2. 데이터의 저장 관점 에서 중앙 집중화된 하나의 데이터베이스를 사용하는 것이 아니라 **서비스별로** 데이터베이스를 사용합니다.
      >  MSA는 서비스가 API에서 데이터베이스까지 분리되는 수직적 분할원칙에 따릅니다.

3. 독립된 DB를 가지게 되면 각 서비스에 따라 DB의 종류 자체를 다르게 사용할 수도 있습니다.
      >  그러나 이는 데이터 분산으로 인해 **트랜잭션** 문제가 발생할 수 있습니다.

## MSA의 장점

- 개발
    - 팀 단위로 기술 스택을 다르게 가져갈 수 있습니다.
- 배포
    - 서비스별로 독립적 배포가 가능합니다.
    - 전체 서비스의 중단이 없습니다.
- 확장
    - 각 서비스의 부하에 따라 개별적으로 scale-out이 가능합니다.
- 장애
    - 장애가 전체 서비스로 확장될 가능성이 적습니다.

## MSA의 단점

서비스가 다양해지고 그만큼 복잡해지면서 여러 단점이 생깁니다.

- 성능
    - MSA는 서비스간 호출을 API통신을 사용하기 때문에  JSON, XML 등을 데이터모델로 변환할때 마샬링 오버헤드가 발생합니다.
- 메모리
    - 각 서비스를 독립서버에 분할 배치하기 때문에 중복되는 모듈이 증가합니다.
    - 하지만 요즘 하드웨어 이슈는 문제가 되지 않습니다.
- 테스팅
    - 서비스가 분산되어 시나리오에 따른 기능 테스트가 복잡합니다.
- 운영
    - 서비스마다 서버가 존재하므로 운영 시스템의 개수가 늘어나고 필요한 기술도 증가합니다.
- 서비스 간 트랜잭션 처리
    - API 기반의 여러 서비스를 하나의 트랜잭션으로 묶는 것은 거의 불가능하기 때문에 DB의 롤백할 수 없습니다.
    - 해결법) 보상 트랜잭션(Compensation Transaction)으로 에러가 발생할 경우, 에러 처리 로직을 구현해줍니다.
